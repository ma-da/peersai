<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Farsight Transcript Search — TF-IDF + Semantic Rerank</title>

<style>
  :root { --bg:#BCD0D6; --fg:#eaf0f1; --muted:#422F05; --accent:#79ffe1; --card:#151a1f; --ring:#2b3540; }
  *{ box-sizing:border-box }
  body{ margin:0; font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; background:var(--bg); color:var(--fg) }
  header{ padding:20px }
  h1 {color: var(--muted)}
  main{ max-width:1000px; margin:0 auto; padding:24px }
  a { font-weight: bold }
  a:hover { background-color: black; color: var(--accent) }  
  .row{ display:grid; grid-template-columns:1fr auto; gap:12px; margin-top:12px }
  input[type="text"]{ width:100%; padding:12px 14px; border-radius:12px; border:1px solid var(--ring); background:var(--card); color:var(--fg) }
  img { display: block; margin: 0 auto; max-width: 80%; height: auto; }
  button{ padding:12px 18px; border-radius:12px; border:1px solid var(--ring); background:var(--card); color:var(--fg); cursor:pointer }
  button:hover{ outline:1px solid var(--accent) }
  .status{ margin-top:8px; color:var(--muted); font-size:14px }
  .progress{ height:8px; width:100%; border-radius:999px; background:var(--accent); overflow:hidden; margin:10px 0 18px; border:1px solid var(--ring) }
  .bar{ height:100%; width:0%; background:linear-gradient(90deg, var(--accent), #88f) }
  .results{ display:grid; gap:14px }
  .card{ padding:14px 16px; background:var(--card); border:1px solid var(--ring); border-radius:16px }
  .meta{ font-size:13px; color:var(--muted); display:flex; gap:10px; flex-wrap:wrap }
  .pill{ padding:1px 8px; border:1px solid var(--ring); border-radius:999px }
  .score{ color:var(--accent); font-weight:600 }
  .title a{ color:var(--fg); text-decoration:none; border-bottom:1px dashed var(--ring) }
  .chunk{ white-space:pre-wrap; word-break:break-word }
  footer{ max-width:1000px; margin:0 auto; padding:24px; color:var(--muted); font-size:13px; text-align:center }
  .modal{position:fixed; inset:0; display:block; opacity:0; pointer-events:none; transition:opacity .2s ease;}
  .modal.is-open{opacity:1; pointer-events:auto;}
  .modal__backdrop{position:absolute; inset:0; background:rgba(0,0,0,.6);}
  .modal__dialog{
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    background:var(--card, #111); border:1px solid var(--ring, #2b3540);
    border-radius:12px; padding:12px; max-width:90vw; max-height:90vh; box-shadow:0 10px 30px rgba(0,0,0,.4);
  }
  .modal__dialog img{display:block; max-width:86vw; max-height:72vh; width:auto; height:auto; margin:0 auto;}
  .modal__caption{margin-top:8px; color:var(--muted,#a8b3b7); font-size:14px; text-align:center;}
  .modal__close{
    position:absolute; top:8px; right:8px; border:1px solid var(--ring,#2b3540);
    background:transparent; color:var(--fg,#eaf0f1); border-radius:8px; padding:4px 10px; cursor:pointer;
  }

</style>
</head>
<body>

<header>
  <main style="padding:0">
    <h1 style="margin:0;font-size:24px">Farsight Transcript Search — TF-IDF + Semantic Re-ranking</h1>
    <div class="row">
      <input id="q" type="text" placeholder="Type your question… e.g., 'crystals engraved with symbols'">
      <button id="go">Search</button>
    </div>
    <div class="status" id="status">Loading dataset…</div>
    <div class="progress" aria-hidden="true"><div class="bar" id="bar"></div></div>
  </main>
</header>

<main>
  <div class="results" id="results"></div>
</main>

<footer>
  <p>Here you can easily search the <a href="https://farsight.org/FarsightPress/Publication_Dates_for_Farsight_Projects" target="_blank">Farsight Institute Vault</a> material. The page provides instant TF-IDF matches, then a semantic re-ranking of the best matches that takes a little longer. Once re-ranking is complete, 20 dataset entries are displayed with titles that link to each entry's Farsight page. <a href="#" data-img="https://rstory.mypinata.cloud/ipfs/bafybeihrzl7uks6nwxyxwzu2j6s4byysjsglsejiufgduin6zgtbjba7km" data-caption="Farsight wordcloud">View word cloud</a>.</p> 
  <p>Page by <a href="https://freemindgazette.substack.com/" target="_blank">Mark Bailey</a> of <a href="https://www.wanttoknow.info/" target="_blank">WantToKnow.info</a></p>

</footer>

<div id="img-modal" class="modal" aria-hidden="true" role="dialog" aria-modal="true">
  <div class="modal__backdrop" data-close></div>
  <div class="modal__dialog" role="document">
    <button class="modal__close" aria-label="Close" data-close>&times;</button>
    <img id="modal-img" alt="" />
    <div id="modal-caption" class="modal__caption"></div>
  </div>
</div>

<script>
(function(){
  const modal = document.getElementById('img-modal');
  const imgEl = document.getElementById('modal-img');
  const capEl = document.getElementById('modal-caption');
  const closeSelectors = '[data-close]';

  function openModal(src, caption){
    imgEl.src = src;
    imgEl.alt = caption || '';
    capEl.textContent = caption || '';
    modal.classList.add('is-open');
    modal.setAttribute('aria-hidden','false');
    document.body.style.overflow = 'hidden';
    // focus the close button for accessibility
    const btn = modal.querySelector('.modal__close');
    if (btn) btn.focus();
  }

  function closeModal(){
    modal.classList.remove('is-open');
    modal.setAttribute('aria-hidden','true');
    document.body.style.overflow = '';
    imgEl.src = '';
  }

  // Open on any click of an element with data-img
  document.addEventListener('click', (e) => {
    const trigger = e.target.closest('[data-img]');
    if (trigger) {
      e.preventDefault();
      openModal(trigger.getAttribute('data-img'), trigger.getAttribute('data-caption') || trigger.textContent.trim());
      return;
    }
    // Close on backdrop or ✕
    if (e.target.closest(closeSelectors)) {
      e.preventDefault();
      closeModal();
    }
  });

  // Close on ESC
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && modal.classList.contains('is-open')) closeModal();
  });
})();
</script>


<script type="module">
/* ---------------- CONFIG ---------------- */
const DATA_CID  = "bafybeig66qdfmnom2vkbr33ro2rby6nyak4tucr4nivw27cjd4jxeummmu"; // your chunks JSON
const INDEX_CID = "bafybeigenv42ihgthvzs2bgjiyzx5iixqbuemqrxrjp3j3udgyknhetjxy"; // your precomputed tfidf_index.json

// Pinata gateway URLs (filename hints help content-type)
const DATA_URL  = `https://rstory.mypinata.cloud/ipfs/${DATA_CID}?filename=farsight_chunks.json`;
const INDEX_URL = `https://rstory.mypinata.cloud/ipfs/${INDEX_CID}?filename=tfidf_index.json`;

// Results & rerank
const TOP_K_DISPLAY   = 20;   // show this many
const RERANK_POOL     = 200;  // TF-IDF top-N to semantically rerank
const BATCH_SIZE_EMBED = 8;   // embedding batch size

// Embedding model (Transformers.js)
import { pipeline } from "https://cdn.jsdelivr.net/npm/@xenova/transformers/dist/transformers.min.js";
const MODEL_ID = "Xenova/bge-small-en-v1.5";
const PIPELINE_TASK = "feature-extraction";
const USE_BGE_PREFIX = false; // set true for asymmetric retrieval (query/passages prefixes)

/* ---------------- DOM helpers ---------------- */
const $ = sel => document.querySelector(sel);
const statusEl = $("#status");
const barEl = $("#bar");
const resultsEl = $("#results");
function setStatus(t){ if(statusEl) statusEl.textContent = t; }
function setBar(ratio){ if(barEl) barEl.style.width = `${Math.max(0, Math.min(1, ratio))*100}%`; }
function escapeHtml(s){ return (s||"").replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c])); }

/* ---------------- Math helpers ---------------- */
function l2norm(a){ let s=0; for (let i=0;i<a.length;i++) s+=a[i]*a[i]; return Math.sqrt(s); }
function normalize(v){ const n=l2norm(v); if(n){ for(let i=0;i<v.length;i++) v[i]/=n; } return v; }
function dot(a,b){ let s=0; for (let i=0;i<a.length;i++) s+=a[i]*b[i]; return s; }

/* ---------------- Data loader ---------------- */
async function fetchData() {
  setStatus("Fetching dataset…");
  const res = await fetch(DATA_URL, { cache: "force-cache" });
  if (!res.ok) throw new Error(`HTTP ${res.status} loading dataset`);
  const ct = (res.headers.get("content-type") || "").toLowerCase();
  if (ct.includes("ndjson") || ct.includes("jsonl")) {
    const reader = res.body.getReader(), dec = new TextDecoder();
    let buf = "", all = [];
    for(;;){
      const { value, done } = await reader.read();
      if (done) break;
      buf += dec.decode(value, { stream:true });
      let idx;
      while((idx = buf.indexOf("\n")) >= 0){
        const line = buf.slice(0, idx); buf = buf.slice(idx+1);
        if (line.trim()) all.push(JSON.parse(line));
      }
    }
    if (buf.trim()) all.push(JSON.parse(buf));
    return all;
  } else {
    return await res.json();
  }
}

/* ---------------- Tokenization (match your precompute script) ----------- Ask ----- */
const STOP = new Set((
  "a an and are as at be but by for from has have in into is it its " +
  "of on or over such that the their then there these this to was were will with without " +
  "i you he she they we them his her our your my mine ours yours theirs not no yes do did done " +
  "what when where who why how which"
).split(/\s+/));
const tokenRe = /[A-Za-z][A-Za-z'-]{1,}/g;
function tokenize(s){
  const out = [];
  for (const m of (s || "").toLowerCase().matchAll(tokenRe)) {
    const w = m[0];
    if (w.length >= 2 && !STOP.has(w)) out.push(w);
  }
  return out;
}

/* ---------------- Precomputed TF-IDF index (packed arrays) ---------------- */
let TFIDF = {
  vocab: null,           // string[]
  term2idx: null,        // Map token -> idx
  idf: null,             // Float32Array
  offsets: null,         // Uint32Array (length = vocab.length + 1)
  docIds: null,          // Uint32Array (total postings)
  weights: null,         // Float32Array (normalized doc weights)
  docCount: 0
};

async function loadPrecomputedIndex(){
  setStatus("Fetching TF-IDF index…");
  const res = await fetch(INDEX_URL, { cache: "force-cache" });
  if (!res.ok) throw new Error(`HTTP ${res.status} loading TF-IDF index`);
  const packed = await res.json();

  TFIDF.vocab    = packed.vocab;
  TFIDF.term2idx = new Map(TFIDF.vocab.map((t,i)=>[t,i]));
  TFIDF.idf      = Float32Array.from(packed.idf);
  TFIDF.offsets  = Uint32Array.from(packed.offsets);
  TFIDF.docIds   = Uint32Array.from(packed.docIds);
  TFIDF.weights  = Float32Array.from(packed.weights);
  TFIDF.docCount = packed.docCount ?? 0;

  setStatus(`TF-IDF index ready (vocab=${TFIDF.vocab.length}, postings=${TFIDF.docIds.length}).`);
}

// Cosine search via packed postings (returns [{id, score}, …] desc)
function tfidfSearch(query, limit = 1000){
  const toks = tokenize(query);
  if (toks.length === 0) return [];

  // query counts → tf-idf (log tf) → normalize
  const qCounts = Object.create(null);
  for (const t of toks) qCounts[t] = (qCounts[t] || 0) + 1;

  const qTerms = [];     // term indices present in vocab
  const qW = [];         // normalized weights
  let sumsq = 0;
  for (const t in qCounts){
    const idx = TFIDF.term2idx.get(t);
    if (idx === undefined) continue; // OOV
    const tfw = 1 + Math.log(qCounts[t]);
    const w = tfw * TFIDF.idf[idx];
    if (w > 0){ qTerms.push(idx); qW.push(w); sumsq += w*w; }
  }
  if (qTerms.length === 0) return [];

  const qn = Math.sqrt(Math.max(sumsq, 1e-12));
  for (let i=0;i<qW.length;i++) qW[i] /= qn;

  const docN = TFIDF.docCount;
  const scores = new Float32Array(docN);

  for (let k=0; k<qTerms.length; k++){
    const termIdx = qTerms[k], qw = qW[k];
    const start = TFIDF.offsets[termIdx], end = TFIDF.offsets[termIdx + 1];
    for (let p = start; p < end; p++){
      const doc = TFIDF.docIds[p];
      scores[doc] += qw * TFIDF.weights[p]; // cosine
    }
  }

  const out = [];
  for (let i=0;i<docN;i++){ const s = scores[i]; if (s > 0) out.push({ id:i, score:s }); }
  out.sort((a,b)=> b.score - a.score);
  return out.slice(0, limit);
}

/* ---------------- Embedding (Transformers.js) ---------------- */
let embedder;
async function getEmbedder(){
  if (!embedder) {
    setStatus("Loading semantic model…");
    embedder = await pipeline(PIPELINE_TASK, MODEL_ID, {
      progress_callback: (p) => { if (p && p.loaded && p.total) setBar(p.loaded/p.total); }
    });
    setBar(0);
  }
  return embedder;
}
function withPrefix(text, isQuery){
  if (!USE_BGE_PREFIX) return text;
  return isQuery ? `query: ${text}` : `passage: ${text}`;
}
async function embedText(text, { isQuery=false } = {}){
  const pipe = await getEmbedder();
  const out = await pipe(withPrefix(text, isQuery), { pooling: "mean", normalize: false });
  const vec = out?.data ? out.data : out;
  return normalize(Float32Array.from(vec));
}
async function embedTextsBatch(texts, batchSize = BATCH_SIZE_EMBED, { isQuery=false } = {}){
  const out = [];
  const total = texts.length || 1;

  for (let i = 0; i < total; i += batchSize){
    const batch = texts.slice(i, i + batchSize);
    const vecs  = await Promise.all(batch.map(t => embedText(t, { isQuery })));
    out.push(...vecs);

    // progress: reserve last 20% for scoring
    const done = Math.min(i + batch.length, total);
    setStatus(`Re-ranking… embedding ${done}/${total}`);
    setBar(0.8 * (done / total));

    await new Promise(r => setTimeout(r, 0)); // yield to UI
  }
  return out;
}

/* ---------------- Render ---------------- */
function renderResultsFromPairs(rows, pairs){
  resultsEl.innerHTML = "";
  for (const [id, score] of pairs){
    const r = rows[id];
    const el = document.createElement("div");
    el.className = "card";
    el.innerHTML = `
      <div class="meta">
        <span class="pill">${r.section || r.title || ""}</span>
        <span>${r.publication_date ? new Date(r.publication_date).toDateString() : ""}</span>
        <span class="score">score=${Number(score).toFixed(3)}</span>
      </div>
      <div class="title" style="margin-top:6px; margin-bottom:8px;">
        ${r.title_url ? `<a href="${r.title_url}" target="_blank" rel="noopener noreferrer">${escapeHtml(r.title||"(untitled)")}</a>`
                      : `<span>${escapeHtml(r.title||"(untitled)")}</span>`}
      </div>
      <div class="chunk">${escapeHtml(r.chunk_text || "")}</div>
    `;
    resultsEl.appendChild(el);
  }
}

/* ---------------- App logic ---------------- */
let DATA_ROWS = [];

async function init(){
  try {
    setBar(0);
    DATA_ROWS = await fetchData();
    // Minimal sanity: must have chunk_text
    DATA_ROWS = DATA_ROWS.filter(r => typeof r.chunk_text === "string" && r.chunk_text.trim().length > 0);

    await loadPrecomputedIndex();  // ← use your packed index from IPFS

    setStatus("Ready? Ask your question and press Search");
    setBar(0);
  } catch (e){
    console.error(e);
    setStatus("Initialization failed. See console.");
  }
}
init();

async function doSearch(){
  const q = $("#q").value.trim(); 
  if (!q) return;

  // ---- 1) Instant TF-IDF preview ----
  setStatus("Searching (TF-IDF) …");
  setBar(0);
  let tfidfCandidates = tfidfSearch(q, Math.max(RERANK_POOL, TOP_K_DISPLAY));

  if (tfidfCandidates.length) {
    const initial = tfidfCandidates.slice(0, TOP_K_DISPLAY).map(h => [h.id, h.score]);
    renderResultsFromPairs(DATA_ROWS, initial);
  } else {
    resultsEl.innerHTML = "<div class='card'><div class='meta'>No lexical matches — computing semantic fallback…</div></div>";
  }

  // ---- 2) Semantic rerank (with visible progress) ----
  setStatus("Re-ranking semantically…");
  setBar(0.02);

  // Candidate pool for rerank
  let pool = tfidfCandidates.slice(0, Math.min(RERANK_POOL, tfidfCandidates.length));
  if (pool.length === 0) {
    const count = Math.min(RERANK_POOL, DATA_ROWS.length);
    pool = Array.from({length: count}, (_, i) => ({ id: i, score: 0 }));
  }

  // Embed query (small progress bump)
  const qvec = await embedText(q, { isQuery: true });
  setBar(0.08);

  // Embed candidates in batches, update bar up to ~80%
  const texts = pool.map(h => DATA_ROWS[h.id].chunk_text || "");
  const total = texts.length || 1;
  const batchSize = Math.max(1, BATCH_SIZE_EMBED || 8);
  const cvecs = new Array(total);

  for (let i = 0; i < total; i += batchSize) {
    const batch = texts.slice(i, i + batchSize);
    const vecs  = await Promise.all(batch.map(t => embedText(t, { isQuery: false })));
    for (let j = 0; j < vecs.length; j++) cvecs[i + j] = vecs[j];

    const done = Math.min(i + batch.length, total);
    const frac = done / total;
    setStatus(`Re-ranking… embedding ${done}/${total}`);
    setBar(0.08 + 0.72 * frac); // 8% → 80%
    await new Promise(r => setTimeout(r, 0)); // yield to UI
  }

  // Score + final 20% of the bar
  setStatus("Re-ranking… scoring");
  const scored = new Array(total);
  for (let i = 0; i < total; i++) {
    scored[i] = [pool[i].id, dot(qvec, cvecs[i])];

    if ((i & 31) === 0 || i === total - 1) {
      const frac = (i + 1) / total;
      setBar(0.80 + 0.20 * frac); // 80% → 100%
      await new Promise(r => setTimeout(r, 0));
    }
  }

  scored.sort((a,b) => b[1] - a[1]);
  const finalTop = scored.slice(0, TOP_K_DISPLAY);

  renderResultsFromPairs(DATA_ROWS, finalTop);
  setStatus(`Semantically re-ranked top ${TOP_K_DISPLAY}.`);
  setBar(0); // set to 1 if you prefer leaving it 'full' after completion
}

/* UI events */
$("#go")?.addEventListener("click", doSearch);
$("#q")?.addEventListener("keydown", (e) => { if (e.key === "Enter") doSearch(); });
</script>

</body>
</html>
